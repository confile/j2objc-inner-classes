//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: jar:file:libSrc/json-20140107-sources.jar!org/json/JSONTokener.java
//


#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "JSONTokener.h"
#include "java/io/BufferedReader.h"
#include "java/io/IOException.h"
#include "java/io/InputStream.h"
#include "java/io/InputStreamReader.h"
#include "java/io/Reader.h"
#include "java/io/StringReader.h"
#include "java/lang/Integer.h"
#include "java/lang/StringBuffer.h"
#include "org/json/JSONArray.h"
#include "org/json/JSONException.h"
#include "org/json/JSONObject.h"

@class JavaIoReader;

@interface OrgJsonJSONTokener () {
 @public
  jlong character_;
  jboolean eof_;
  jlong index_;
  jlong line_;
  jchar previous_;
  JavaIoReader *reader_;
  jboolean usePrevious_;
}
@end

J2OBJC_FIELD_SETTER(OrgJsonJSONTokener, reader_, JavaIoReader *)

@implementation OrgJsonJSONTokener

- (instancetype)initWithJavaIoReader:(JavaIoReader *)reader {
  OrgJsonJSONTokener_initWithJavaIoReader_(self, reader);
  return self;
}

- (instancetype)initWithJavaIoInputStream:(JavaIoInputStream *)inputStream {
  OrgJsonJSONTokener_initWithJavaIoInputStream_(self, inputStream);
  return self;
}

- (instancetype)initWithNSString:(NSString *)s {
  OrgJsonJSONTokener_initWithNSString_(self, s);
  return self;
}

- (void)back {
  if (self->usePrevious_ || self->index_ <= 0) {
    @throw new_OrgJsonJSONException_initWithNSString_(@"Stepping back two steps is not supported");
  }
  self->index_ -= 1;
  self->character_ -= 1;
  self->usePrevious_ = YES;
  self->eof_ = NO;
}

+ (jint)dehexcharWithChar:(jchar)c {
  return OrgJsonJSONTokener_dehexcharWithChar_(c);
}

- (jboolean)end {
  return self->eof_ && !self->usePrevious_;
}

- (jboolean)more {
  [self next];
  if ([self end]) {
    return NO;
  }
  [self back];
  return YES;
}

- (jchar)next {
  jint c;
  if (self->usePrevious_) {
    self->usePrevious_ = NO;
    c = self->previous_;
  }
  else {
    @try {
      c = [((JavaIoReader *) nil_chk(self->reader_)) read];
    }
    @catch (JavaIoIOException *exception) {
      @throw new_OrgJsonJSONException_initWithJavaLangThrowable_(exception);
    }
    if (c <= 0) {
      self->eof_ = YES;
      c = 0;
    }
  }
  self->index_ += 1;
  if (self->previous_ == 0x000d) {
    self->line_ += 1;
    self->character_ = c == 0x000a ? 0 : 1;
  }
  else if (c == 0x000a) {
    self->line_ += 1;
    self->character_ = 0;
  }
  else {
    self->character_ += 1;
  }
  self->previous_ = (jchar) c;
  return self->previous_;
}

- (jchar)nextWithChar:(jchar)c {
  jchar n = [self next];
  if (n != c) {
    @throw [self syntaxErrorWithNSString:JreStrcat("$C$CC", @"Expected '", c, @"' and instead saw '", n, '\'')];
  }
  return n;
}

- (NSString *)nextWithInt:(jint)n {
  if (n == 0) {
    return @"";
  }
  IOSCharArray *chars = [IOSCharArray newArrayWithLength:n];
  jint pos = 0;
  while (pos < n) {
    *IOSCharArray_GetRef(chars, pos) = [self next];
    if ([self end]) {
      @throw [self syntaxErrorWithNSString:@"Substring bounds error"];
    }
    pos += 1;
  }
  return [NSString stringWithCharacters:chars];
}

- (jchar)nextClean {
  for (; ; ) {
    jchar c = [self next];
    if (c == 0 || c > ' ') {
      return c;
    }
  }
}

- (NSString *)nextStringWithChar:(jchar)quote {
  jchar c;
  JavaLangStringBuffer *sb = new_JavaLangStringBuffer_init();
  for (; ; ) {
    c = [self next];
    switch (c) {
      case 0:
      case 0x000a:
      case 0x000d:
      @throw [self syntaxErrorWithNSString:@"Unterminated string"];
      case '\\':
      c = [self next];
      switch (c) {
        case 'b':
        (void) [sb appendWithChar:0x0008];
        break;
        case 't':
        (void) [sb appendWithChar:0x0009];
        break;
        case 'n':
        (void) [sb appendWithChar:0x000a];
        break;
        case 'f':
        (void) [sb appendWithChar:0x000c];
        break;
        case 'r':
        (void) [sb appendWithChar:0x000d];
        break;
        case 'u':
        (void) [sb appendWithChar:(jchar) JavaLangInteger_parseIntWithNSString_withInt_([self nextWithInt:4], 16)];
        break;
        case '"':
        case '\'':
        case '\\':
        case '/':
        (void) [sb appendWithChar:c];
        break;
        default:
        @throw [self syntaxErrorWithNSString:@"Illegal escape."];
      }
      break;
      default:
      if (c == quote) {
        return [sb description];
      }
      (void) [sb appendWithChar:c];
    }
  }
}

- (NSString *)nextToWithChar:(jchar)delimiter {
  JavaLangStringBuffer *sb = new_JavaLangStringBuffer_init();
  for (; ; ) {
    jchar c = [self next];
    if (c == delimiter || c == 0 || c == 0x000a || c == 0x000d) {
      if (c != 0) {
        [self back];
      }
      return [((NSString *) nil_chk([sb description])) trim];
    }
    (void) [sb appendWithChar:c];
  }
}

- (NSString *)nextToWithNSString:(NSString *)delimiters {
  jchar c;
  JavaLangStringBuffer *sb = new_JavaLangStringBuffer_init();
  for (; ; ) {
    c = [self next];
    if ([((NSString *) nil_chk(delimiters)) indexOf:c] >= 0 || c == 0 || c == 0x000a || c == 0x000d) {
      if (c != 0) {
        [self back];
      }
      return [((NSString *) nil_chk([sb description])) trim];
    }
    (void) [sb appendWithChar:c];
  }
}

- (id)nextValue {
  jchar c = [self nextClean];
  NSString *string;
  switch (c) {
    case '"':
    case '\'':
    return [self nextStringWithChar:c];
    case '{':
    [self back];
    return new_OrgJsonJSONObject_initWithOrgJsonJSONTokener_(self);
    case '[':
    [self back];
    return new_OrgJsonJSONArray_initWithOrgJsonJSONTokener_(self);
  }
  JavaLangStringBuffer *sb = new_JavaLangStringBuffer_init();
  while (c >= ' ' && [@",:]}/\\\"[{;=#" indexOf:c] < 0) {
    (void) [sb appendWithChar:c];
    c = [self next];
  }
  [self back];
  string = [((NSString *) nil_chk([sb description])) trim];
  if ([@"" isEqual:string]) {
    @throw [self syntaxErrorWithNSString:@"Missing value"];
  }
  return OrgJsonJSONObject_stringToValueWithNSString_(string);
}

- (jchar)skipToWithChar:(jchar)to {
  jchar c;
  @try {
    jlong startIndex = self->index_;
    jlong startCharacter = self->character_;
    jlong startLine = self->line_;
    [((JavaIoReader *) nil_chk(self->reader_)) markWithInt:1000000];
    do {
      c = [self next];
      if (c == 0) {
        [self->reader_ reset];
        self->index_ = startIndex;
        self->character_ = startCharacter;
        self->line_ = startLine;
        return c;
      }
    }
    while (c != to);
  }
  @catch (JavaIoIOException *exc) {
    @throw new_OrgJsonJSONException_initWithJavaLangThrowable_(exc);
  }
  [self back];
  return c;
}

- (OrgJsonJSONException *)syntaxErrorWithNSString:(NSString *)message {
  return new_OrgJsonJSONException_initWithNSString_(JreStrcat("$$", message, [self description]));
}

- (NSString *)description {
  return JreStrcat("$J$J$JC", @" at ", self->index_, @" [character ", self->character_, @" line ", self->line_, ']');
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithJavaIoReader:", "JSONTokener", NULL, 0x1, NULL, NULL },
    { "initWithJavaIoInputStream:", "JSONTokener", NULL, 0x1, "Lorg.json.JSONException;", NULL },
    { "initWithNSString:", "JSONTokener", NULL, 0x1, NULL, NULL },
    { "back", NULL, "V", 0x1, "Lorg.json.JSONException;", NULL },
    { "dehexcharWithChar:", "dehexchar", "I", 0x9, NULL, NULL },
    { "end", NULL, "Z", 0x1, NULL, NULL },
    { "more", NULL, "Z", 0x1, "Lorg.json.JSONException;", NULL },
    { "next", NULL, "C", 0x1, "Lorg.json.JSONException;", NULL },
    { "nextWithChar:", "next", "C", 0x1, "Lorg.json.JSONException;", NULL },
    { "nextWithInt:", "next", "Ljava.lang.String;", 0x1, "Lorg.json.JSONException;", NULL },
    { "nextClean", NULL, "C", 0x1, "Lorg.json.JSONException;", NULL },
    { "nextStringWithChar:", "nextString", "Ljava.lang.String;", 0x1, "Lorg.json.JSONException;", NULL },
    { "nextToWithChar:", "nextTo", "Ljava.lang.String;", 0x1, "Lorg.json.JSONException;", NULL },
    { "nextToWithNSString:", "nextTo", "Ljava.lang.String;", 0x1, "Lorg.json.JSONException;", NULL },
    { "nextValue", NULL, "Ljava.lang.Object;", 0x1, "Lorg.json.JSONException;", NULL },
    { "skipToWithChar:", "skipTo", "C", 0x1, "Lorg.json.JSONException;", NULL },
    { "syntaxErrorWithNSString:", "syntaxError", "Lorg.json.JSONException;", 0x1, NULL, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "character_", NULL, 0x2, "J", NULL, NULL,  },
    { "eof_", NULL, 0x2, "Z", NULL, NULL,  },
    { "index_", NULL, 0x2, "J", NULL, NULL,  },
    { "line_", NULL, 0x2, "J", NULL, NULL,  },
    { "previous_", NULL, 0x2, "C", NULL, NULL,  },
    { "reader_", NULL, 0x2, "Ljava.io.Reader;", NULL, NULL,  },
    { "usePrevious_", NULL, 0x2, "Z", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _OrgJsonJSONTokener = { 2, "JSONTokener", "org.json", NULL, 0x1, 18, methods, 7, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_OrgJsonJSONTokener;
}

@end

void OrgJsonJSONTokener_initWithJavaIoReader_(OrgJsonJSONTokener *self, JavaIoReader *reader) {
  (void) NSObject_init(self);
  self->reader_ = [((JavaIoReader *) nil_chk(reader)) markSupported] ? reader : new_JavaIoBufferedReader_initWithJavaIoReader_(reader);
  self->eof_ = NO;
  self->usePrevious_ = NO;
  self->previous_ = 0;
  self->index_ = 0;
  self->character_ = 1;
  self->line_ = 1;
}

OrgJsonJSONTokener *new_OrgJsonJSONTokener_initWithJavaIoReader_(JavaIoReader *reader) {
  OrgJsonJSONTokener *self = [OrgJsonJSONTokener alloc];
  OrgJsonJSONTokener_initWithJavaIoReader_(self, reader);
  return self;
}

void OrgJsonJSONTokener_initWithJavaIoInputStream_(OrgJsonJSONTokener *self, JavaIoInputStream *inputStream) {
  (void) OrgJsonJSONTokener_initWithJavaIoReader_(self, new_JavaIoInputStreamReader_initWithJavaIoInputStream_(inputStream));
}

OrgJsonJSONTokener *new_OrgJsonJSONTokener_initWithJavaIoInputStream_(JavaIoInputStream *inputStream) {
  OrgJsonJSONTokener *self = [OrgJsonJSONTokener alloc];
  OrgJsonJSONTokener_initWithJavaIoInputStream_(self, inputStream);
  return self;
}

void OrgJsonJSONTokener_initWithNSString_(OrgJsonJSONTokener *self, NSString *s) {
  (void) OrgJsonJSONTokener_initWithJavaIoReader_(self, new_JavaIoStringReader_initWithNSString_(s));
}

OrgJsonJSONTokener *new_OrgJsonJSONTokener_initWithNSString_(NSString *s) {
  OrgJsonJSONTokener *self = [OrgJsonJSONTokener alloc];
  OrgJsonJSONTokener_initWithNSString_(self, s);
  return self;
}

jint OrgJsonJSONTokener_dehexcharWithChar_(jchar c) {
  OrgJsonJSONTokener_initialize();
  if (c >= '0' && c <= '9') {
    return c - '0';
  }
  if (c >= 'A' && c <= 'F') {
    return c - ('A' - 10);
  }
  if (c >= 'a' && c <= 'f') {
    return c - ('a' - 10);
  }
  return -1;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgJsonJSONTokener)
